
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/tutorial_01_getting_started.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_tutorial_01_getting_started.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_tutorial_01_getting_started.py:


1 - Getting Started
===================

The main application for :mod:`scikit-gstat <skgstat>` is variogram analysis and `Kriging <https://en.wikipedia.org/wiki/Kriging>`_.
This tutorial will guide you through the most basic functionality of ``scikit-gstat``.
There are other tutorials that will explain specific methods or attributes in ``scikit-gstat`` in more detail.

**What you will learn in this tutorial**

    * How to instantiate :class:`Variogram <skgstat.Variogram>` and :class:`OrdinaryKriging <skgstat.OrdinaryKriging>`
    * How to read a variogram
    * Perform an interpolation
    * Most basic plotting

.. GENERATED FROM PYTHON SOURCE LINES 17-24

.. code-block:: default

    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    from pprint import pprint
    import warnings
    warnings.filterwarnings("ignore")








.. GENERATED FROM PYTHON SOURCE LINES 25-27

The module is called ``skgstat`` and by convention imported as ``skg``.
The :class:`Variogram <skgstat.Variogram>` and :class:`OrdinaryKriging <skgstat.OrdinaryKriging>` classes are available at top level.

.. GENERATED FROM PYTHON SOURCE LINES 27-29

.. code-block:: default

    import skgstat as skg








.. GENERATED FROM PYTHON SOURCE LINES 30-38

1.1 Load data
-------------
SciKit-GStat includes a data submodule, that contains some sample datasets. It also offers some basic random sampling on data sources.
Here we use the well-known Meuse dataset from the R package ``sp`` (https://cran.r-project.org/web/packages/st/index.html). 
If not specified different, the loading function will only export the lead measurements from the data source.

**Note:** The data is distributed along with the package sp under a GPL-3 license.
If you use the data, cite the original authors, not SciKit-GStat for the dataset.

.. GENERATED FROM PYTHON SOURCE LINES 38-45

.. code-block:: default

    src = skg.data.meuse()
    print(src.get('origin'))

    coords, vals = src.get('sample')
    # make a nice table
    pd.DataFrame({'x': coords[:, 0], 'y': coords[:, 1], 'lead': vals.flatten()}).head()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    "Sample dataset of real measurements of heavy metal pollutions
        in the topsoil on a 15x15 meter plot along the river Meuse.
        The data is distributed along with the R-package sp.
        IMPORTANT: If you use this data, cite Pebesma and Bivand (2005)
        and Bivand et al (2013):

          Pebesma EJ, Bivand RS (2005). “Classes and methods for spatial
          data in R.” R News, 5(2), 9–13. https://CRAN.R-project.org/doc/Rnews/.

          Bivand RS, Pebesma E, Gomez-Rubio V (2013). Applied spatial data
          analysis with R, Second edition. Springer, NY. https://asdar-book.org/.

    


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>x</th>
          <th>y</th>
          <th>lead</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>181072</td>
          <td>333611</td>
          <td>299</td>
        </tr>
        <tr>
          <th>1</th>
          <td>181025</td>
          <td>333558</td>
          <td>277</td>
        </tr>
        <tr>
          <th>2</th>
          <td>181165</td>
          <td>333537</td>
          <td>199</td>
        </tr>
        <tr>
          <th>3</th>
          <td>181298</td>
          <td>333484</td>
          <td>116</td>
        </tr>
        <tr>
          <th>4</th>
          <td>181307</td>
          <td>333330</td>
          <td>117</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 46-47

Get a first overview of your data by plotting the `x` and `y` coordinates and visually inspect how the `z` spread out.

.. GENERATED FROM PYTHON SOURCE LINES 47-51

.. code-block:: default

    fig, ax = plt.subplots(1, 1, figsize=(9, 9))
    art = ax.scatter(coords[:, 0], coords[:, 1], s=50, c=vals.flatten(), cmap='plasma')
    plt.colorbar(art)




.. image-sg:: /auto_examples/images/sphx_glr_tutorial_01_getting_started_001.png
   :alt: tutorial 01 getting started
   :srcset: /auto_examples/images/sphx_glr_tutorial_01_getting_started_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x7fdd8223e1f0>



.. GENERATED FROM PYTHON SOURCE LINES 52-77

We can already see a lot from here:

* There are a few hot-spots, most of them aligned along the river-bank.
* Most observations show rather low values

These are already very important insights.

1.2 Build a Variogram
---------------------
As a quick reminder, the variogram relates pair-wise separating distances of `coordinates` and relates them to the *semi-variance* of the corresponding `values` pairs. The default estimator used is the Matheron estimator:

.. math::

  \gamma (h) = \frac{1}{2N(h)} * \sum_{i=1}^{N(h)}(Z(x_i) - Z(x_{i + h}))^2

For more details, please refer to the `User Guide <https://mmaelicke.github.io/scikit-gstat/userguide/variogram.html#experimental-variograms>`_.

The :class:`Variogram <skgstat.Variogram>` class takes at least two arguments. 
The :func:`coordinates <skgstat.Variogram.coordinates>` and the :func:`values <skgstat.Variogram.values>` observed at these locations.
If you use older versions, <ou should also at least set the ``normalize`` parameter to explicitly, as it changed it's default value in
version `0.2.8` to ``False``. This attribute affects only the plotting, not the variogram values.
Additionally, the number of bins is set to 15, because we have fairly many observations and the default value of 10 is unnecessarily small.
The ``maxlag`` set the maximum distance for the last bin. As we have no other additional information about expected correlation lengths,
we can either set nothing and use the full distance matrix, or set it i.e. to ``'median'``, which will restrict the distance matrix to only
use half of all combinations.

.. GENERATED FROM PYTHON SOURCE LINES 77-80

.. code-block:: default

    V = skg.Variogram(coords, vals.flatten(), maxlag='median', n_lags=15, normalize=False)
    fig = V.plot(show=False)




.. image-sg:: /auto_examples/images/sphx_glr_tutorial_01_getting_started_002.png
   :alt: tutorial 01 getting started
   :srcset: /auto_examples/images/sphx_glr_tutorial_01_getting_started_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 81-89

The upper subplot show the histogram for the count of point-pairs in each lag class. You can see various things here:

  * As expected, there is a clear spatial dependency, because semi-variance increases with distance (blue dots)
  * The default `spherical` variogram model is well fitted to the experimental data
  * The shape of the dependency is **not** captured quite well, but fair enough for this example
  * The first two bins are not well captured, suggesting either the use of a nugget, or a different model.

The sill of the variogram should correspond with the field variance. The field is unknown, but we can compare the sill to the *sample* variance:

.. GENERATED FROM PYTHON SOURCE LINES 89-91

.. code-block:: default

    print('Sample variance: %.2f   Variogram sill: %.2f' % (vals.flatten().var(), V.describe()['sill']))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Sample variance: 12312.20   Variogram sill: 16066.26




.. GENERATED FROM PYTHON SOURCE LINES 92-94

The ``describe`` method will return the most important parameters as a dictionary. 
And we can simply print the variogram ob,ect to the screen, to see all parameters.

.. GENERATED FROM PYTHON SOURCE LINES 94-96

.. code-block:: default

    pprint(V.describe())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'dist_func': 'euclidean',
     'effective_range': 948.7297686242266,
     'estimator': 'matheron',
     'kwargs': {},
     'model': 'spherical',
     'normalized_effective_range': 1302289.1147019006,
     'normalized_nugget': 0,
     'normalized_sill': 284534314.8067728,
     'nugget': 0,
     'params': {'bin_func': 'even',
                'dist_func': 'euclidean',
                'estimator': 'matheron',
                'fit_method': 'trf',
                'fit_sigma': None,
                'maxlag': 1372.6660191029719,
                'model': 'spherical',
                'n_lags': 15,
                'normalize': False,
                'use_nugget': False,
                'verbose': False},
     'sill': 16066.25839544138}




.. GENERATED FROM PYTHON SOURCE LINES 97-98

An even shorter summary is printed by the :class:`Variogram <skgstat.Variogram>` object itself:

.. GENERATED FROM PYTHON SOURCE LINES 98-100

.. code-block:: default

    print(V)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    spherical Variogram
    -------------------
    Estimator:         matheron
            Effective Range:   948.73
            Sill:              16066.26
            Nugget:            0.00
        




.. GENERATED FROM PYTHON SOURCE LINES 101-144

1.3 Kriging
-----------
The Kriging class will now use the Variogram from above to estimate the Kriging weights for each grid cell. This is done by solving a linear equation system. For an unobserved location $s_0$, we can use the distances to 5 observation points and build the system like:

.. math::

  \begin{pmatrix}
  \gamma(s_1, s_1) & \gamma(s_1, s_2) & \gamma(s_1, s_3) & \gamma(s_1, s_4) & \gamma(s_1, s_5) & 1\\
  \gamma(s_2, s_1) & \gamma(s_2, s_2) & \gamma(s_2, s_3) & \gamma(s_2, s_4) & \gamma(s_2, s_5) & 1\\
  \gamma(s_3, s_1) & \gamma(s_3, s_2) & \gamma(s_3, s_3) & \gamma(s_3, s_4) & \gamma(s_3, s_5) & 1\\
  \gamma(s_4, s_1) & \gamma(s_4, s_2) & \gamma(s_4, s_3) & \gamma(s_4, s_4) & \gamma(s_4, s_5) & 1\\
  \gamma(s_5, s_1) & \gamma(s_5, s_2) & \gamma(s_5, s_3) & \gamma(s_5, s_4) & \gamma(s_5, s_5) & 1\\
  1 & 1 & 1 & 1 & 1 & 0 \\
  \end{pmatrix} *
  \begin{bmatrix}
  \lambda_1 \\
  \lambda_2 \\
  \lambda_3 \\
  \lambda_4 \\
  \lambda_5 \\
  \mu \\
  \end{bmatrix} =
  \begin{pmatrix}
  \gamma(s_0, s_1) \\
  \gamma(s_0, s_2) \\
  \gamma(s_0, s_3) \\
  \gamma(s_0, s_4) \\
  \gamma(s_0, s_5) \\
  1 \\
  \end{pmatrix}

For more information, please refer to the `User Guide <https://mmaelicke.github.io/scikit-gstat/userguide/kriging.html#kriging-equation-system>`_.

Consequently, the :class:`OrdinaryKriging <skgstat.OrdinaryKriging>` class needs a :class:`Variogram <skgstat.Variogram>` 
object as a mandatory attribute. Two very important optional attributes are ``min_points`` and ``max_points```.
They will limit the size of the Kriging equation system. As we have 200 observations,
we can require at least 5 neighbors within the range. More than 15 will only unnecessarily slow down the computation.
The ``mode='exact'`` attribute will advise the class to build and solve the system above for each location.

**Note:** The recommended way for kriging applications is to use the interface to :any:`gstools`.
There is an easy-to-use interface via :func:`Variogram.to_gstools <skgstat.Variogram.to_gstools>` 
and :func:`Variogram.to_gs_krige <skgstat.Variogram.to_gs_krige>`.
The getting started tutorial will use the builtin kriging class, anyway.

.. GENERATED FROM PYTHON SOURCE LINES 144-146

.. code-block:: default

    ok = skg.OrdinaryKriging(V, min_points=5, max_points=15, mode='exact')








.. GENERATED FROM PYTHON SOURCE LINES 147-150

The :func:`OrdinaryKriging.transform <skgstat.OrdianryKriging.transform>` method will apply the interpolation for passed arrays of coordinates.
It requires each dimension as a single 1D array. We can easily build a meshgrid of 100x100 coordinates and pass them to the interpolator.
To recieve a 2D result, we can simply reshape the result. The Kriging error will be available as the ``sigma`` attribute of the interpolator.

.. GENERATED FROM PYTHON SOURCE LINES 150-158

.. code-block:: default


    # build the target grid
    x = coords[:, 0]
    y = coords[:, 1]
    xx, yy = np.mgrid[x.min():x.max():100j, y.min():y.max():100j]
    field = ok.transform(xx.flatten(), yy.flatten()).reshape(xx.shape)
    s2 = ok.sigma.reshape(xx.shape)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Warning: for 1779 locations, not enough neighbors were found within the range.




.. GENERATED FROM PYTHON SOURCE LINES 159-160

And finally, we can plot the result.

.. GENERATED FROM PYTHON SOURCE LINES 160-179

.. code-block:: default

    fig, axes = plt.subplots(1, 2, figsize=(16, 8))

    # rescale the coordinates to fit the interpolation raster
    x_ = (x - x.min()) / (x.max() - x.min()) * 100
    y_ = (y - y.min()) / (y.max() - y.min()) * 100

    art = axes[0].matshow(field.T, origin='lower', cmap='plasma', vmin=vals.min(), vmax=vals.max())
    axes[0].set_title('Interpolation')
    axes[0].plot(x_, y_, '+w')
    axes[0].set_xlim((0, 100))
    axes[0].set_ylim((0, 100))
    plt.colorbar(art, ax=axes[0])
    art = axes[1].matshow(s2.T, origin='lower', cmap='YlGn_r')
    axes[1].set_title('Kriging Error')
    plt.colorbar(art, ax=axes[1])
    axes[1].plot(x_, y_, '+w')
    axes[1].set_xlim((0, 100))
    axes[1].set_ylim((0, 100))




.. image-sg:: /auto_examples/images/sphx_glr_tutorial_01_getting_started_003.png
   :alt: Interpolation, Kriging Error
   :srcset: /auto_examples/images/sphx_glr_tutorial_01_getting_started_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    (0.0, 100.0)



.. GENERATED FROM PYTHON SOURCE LINES 180-183

From the Kriging error map, you can see how the interpolation is very certain close to the observation points,
but rather high in areas with only little coverage. You could now define a threshold of maximum accepted Kriging error
variance to mask the interpolation result.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  4.432 seconds)


.. _sphx_glr_download_auto_examples_tutorial_01_getting_started.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_01_getting_started.py <tutorial_01_getting_started.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_01_getting_started.ipynb <tutorial_01_getting_started.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
